#!/usr/bin/env python
import string
import optparse
import os.path as osp
import os
import shutil
import ConfigParser as configparser

SERVERS_PATH='servers'
NGINX_SERVER_TMPL = '''\
# Generated nginx virtual host configuration. 
# DO NOT EDIT MANUALLY. Use the uow script to update this file.
${upstreams}

server {
    listen ${server_port};
    server_name ${server_name};
    location /libs {
        alias ../servers/${group_name}/www/libs;
    }
${aliases}
${proxies}
}'''
NGINX_UPSTREAM_TMPL = '''\
upstream ${name} {
    ${servers}
}'''
NGINX_ALIAS_TMPL = '''\
    location ${url} {
        alias ../servers/${group_name}/${path};
    }
'''
NGINX_PROXY_TMPL = '''\
    location ${url} {
        proxy_pass_header Server;
        proxy_set_header Host $host;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass ${upstream};
    }'''

class NginxTemplate(object):
    def __init__(self, group_name):
        self.template = string.Template(NGINX_SERVER_TMPL)
        self.group_name = group_name
        self.upstreams = []
        self.proxies = []
        self.aliases = []
        self.server_name = None
        self.server_port = None
    
    def render(self):
        args = dict(self.__dict__)
        args['upstreams'] = '\n'.join(self.upstreams)
        args['aliases'] = '\n'.join(self.aliases)
        args['proxies'] = '\n'.join(self.proxies)
        return self.template.substitute(args)

    def assert_complete(self):
        assert(self.server_port is not None and self.server_name is not None)
    
    def add_alias(self, url, path):
        group_name = self.group_name
        tmpl = string.Template(NGINX_ALIAS_TMPL)
        text = tmpl.safe_substitute(locals())
        self.aliases.append(text)
    
    def add_proxy(self, url, upstream):
        tmpl = string.Template(NGINX_PROXY_TMPL)
        text = tmpl.safe_substitute(locals())
        self.proxies.append(text)
        
    def add_upstream(self, name, servers):
        servers = '\n'.join(['server %s;' % server for server in servers])
        tmpl = string.Template(NGINX_UPSTREAM_TMPL)
        text = tmpl.substitute(locals())
        self.upstreams.append(text)
        
    def set_server_port(self, port):
        self.server_port = port
        
    def set_server_name(self, name):
        self.server_name = name

class NginxHandler(object):
    def __init__(self, group_name, nginx_tmpl):
        self.group_name = group_name
        self.nginx_tmpl = nginx_tmpl

    def dispatch(self, section, name, value, cp):
        getattr(self, name)(section, value, cp)
        
    def server_port(self, section, value, cp):
        self.nginx_tmpl.set_server_port(int(value))
    
    def server_name(self, section, value, cp):
        self.nginx_tmpl.set_server_name(value)

class ComponentHandler(object):
    def __init__(self, group_name, nginx_tmpl):
        self.group_name = group_name
        self.nginx_tmpl = nginx_tmpl
        
    def dispatch(self, section, name, value, cp):
        getattr(self, name)(section, value, cp)
    
    def update(self):
        pass

    def init(self, section, value, cp):
        os.system(value)
        
    def program(self, section, value, cp):
        # exist to avoid unsupported key warning
        pass
    
    def symlinks(self, section, value, cp):
        pairs = value.split(',')
        for source, target in zip(pairs[::2], pairs[1::2]):
            source, target = source.strip(), target.strip()
            dtarget = osp.dirname(target)
            # make source relative to target
            rel = osp.join(*(['..'] * len(dtarget.split('/'))))
            source = osp.join(rel, source)
            # build intervening paths
            try:
                os.makedirs(dtarget)
            except OSError:
                pass
            os.symlink(source, target)
            print 'Symlinked %s -> %s' % (target, source)
    
    def proxies(self, section, value, cp):
        program = cp.get(section, 'program')
        psection = 'program:%s' % program
        # create upstreams for proxies
        start = cp.getint(psection, 'first_port')
        count = cp.getint(psection, 'numprocs')
        servers = ['127.0.0.1:%d' % port for port in range(start, start+count)]
        self.nginx_tmpl.add_upstream(program, servers)
        # add proxies
        pairs = value.split(',')
        for url, path in zip(pairs[::2], pairs[1::2]):
            self.nginx_tmpl.add_proxy(url, path)
            print 'Proxied %s -> %s' % (path, url)
            
    def aliases(self, section, value, cp):
        pairs = value.split(',')
        for url, path in zip(pairs[::2], pairs[1::2]):
            self.nginx_tmpl.add_alias(url, path)
            print 'Aliased %s -> %s' % (path, url)

class ProgramHandler(object):
    def __init__(self, group_name, nginx_tmpl):
        self.group_name = group_name
        self.nginx_tmpl = nginx_tmpl
        
    def dispatch(self, section, name, value, cp):
        getattr(self, name)(section, value, cp)
    
    def user(self, section, value, cp):
        os.seteuid(0)
        try:
            path = cp.get(section, 'directory')
            path = '/'.join(path.split('/')[2:])
            os.system('chown -h %s %s' % (value, path))
            os.system('chown -R -L %s %s' % (value, path))
        finally:
            os.seteuid(int(os.environ.get('SUDO_UID', 0)))
        print 'Set ownership %s -> %s' % (value, path)

def _prompt(msg, default):
    while 1:
        i = raw_input('%s [%s] ' % (msg, default)) or default
        i = i.lower()
        if i in ['y', 'yes']:
            return True
        elif i in ['n', 'no']:
            return False

def init(group_name):
    # require root to set owner / group
    if os.getuid():
        raise ValueError('You must su or sudo to root to init.')
    # get pre-sudo user
    owner = int(os.environ.get('SUDO_UID', 0))
    # get path info
    cwd = os.getcwd()
    dname = osp.join(SERVERS_PATH, group_name)
    cname = osp.join(SERVERS_PATH, group_name+'.conf')
    # read config file
    cp = configparser.ConfigParser()
    cp.readfp(open(cname))
    
    # check if dir exists
    if osp.isdir(dname):
        # confirm dir reset
        reset = _prompt('Are your sure you want to delete %s?' % group_name, 'n')
        if reset:
            print 'Deleting server directories ...'
            shutil.rmtree(dname)
            print 'Done deleting'
        else:
            print 'Aborted'
            return

    # switch to pre-sudo user
    os.seteuid(owner)
    # switch into dname to somewhat sandbox commands
    os.makedirs(dname)
    os.chdir(dname)
    
    # create standard folders
    print 'Creating server directories ...'
    # rwx, rx, rx
    os.makedirs(osp.join('www', 'libs'), 0765)
    os.makedirs(osp.join('services', 'logs'), 0765)
    os.makedirs(osp.join('components'), 0765)
    print 'Done creating server directories\n'
    # start an nginx template
    tmpl = NginxTemplate(group_name)

    # get nginx info
    nginx = NginxHandler(group_name, tmpl)
    print 'Handling "nginx" section ...',
    for name, value in cp.items('nginx'):
        try:
            # dispatch to handle keys
            nginx.dispatch('nginx', name, value, cp)
        except AttributeError:
            pass
            #print 'Unknown key "%s" in section "nginx"' % (name)
    print 'Done handling "nginx"\n'

    # get components
    components = ComponentHandler(group_name, tmpl)
    for section in filter(lambda x: x.startswith('component'), cp.sections()):
        print 'Handling "%s" section ...' % section
        # handle init first if it exists
        if cp.has_option(section, 'init'):
            components.dispatch(section, 'init', cp.get(section, 'init'), cp)
        for name, value in cp.items(section):
            if name in ['init', 'update']: continue
            try:
                # dispatch to handle keys
                components.dispatch(section, name, value, cp)
            except AttributeError:
                print 'Unknown key "%s" in section "%s"' % (name, section)
        print 'Done handling "%s"\n' % section

    # chown everything to the original user
    # @todo: wouldn't need this if we used subprocess instead of os.system probably
    print 'Setting ownership to user %s' % owner
    os.chdir(cwd)
    os.system('chown -R -L %s %s' % (owner, dname))
    os.system('chown -R -h %s %s' % (owner, dname))
    os.chdir(dname)
    print 'Done setting user\n'

    # get programs
    programs = ProgramHandler(group_name, tmpl)
    for section in filter(lambda x: x.startswith('program'), cp.sections()):
        print 'Handling "%s" section ...' % section
        if cp.has_option(section, 'user'):
            programs.dispatch(section, 'user', cp.get(section, 'user'), cp)
        print 'Done handling "%s"\n' % section

    # make sure we have all required nginx info
    tmpl.assert_complete()    
    # write nginx config
    conf = tmpl.render()
    os.chdir(cwd)
    fh = file(osp.join('nginx', 'servers', group_name+'.nginx.conf'), 'w')
    fh.write(conf)
    fh.close()

    print 'Success. Start supervisord or use supervisorctl to reload the config.'

def update(group_name):
    # read config file
    # get non-existing components
    # create symlinks
    # generate nginx config sections
    # ask to update existing components
    # prompt to reload supervisord?
    pass

def remove(group_name):
    # require root to set owner / group
    if os.getuid():
        raise ValueError('You must su or sudo to root to remove.')
    # get path info
    cwd = os.getcwd()
    dname = osp.join(SERVERS_PATH, group_name)
    # check if dir exists
    if osp.isdir(dname):
        # confirm dir reset
        reset = _prompt('Are your sure you want to delete %s?' % group_name, 'n')
        if reset:
            print 'Deleting server directories ...'
            shutil.rmtree(dname)
            print 'Deleting server nginx config ...'
            os.unlink(osp.join('nginx', 'servers', group_name+'.nginx.conf'))
            print 'Done deleting'
        else:
            print 'Aborted'
            return
    else:
        print 'Nothing to remove'

def run_from_args():
    usage = "usage: %prog [init|update|remove] [name]"
    parser = optparse.OptionParser(usage=usage)
    (options, args) = parser.parse_args()
    if len(args) < 2:
        parser.print_usage()
    elif args[0] == 'init':
        init(args[1])
    elif args[0] == 'update':
        update(args[1])
    elif args[0] == 'remove':
        remove(args[1])
    else:
        parser.print_usage()

if __name__ == '__main__':
    run_from_args()